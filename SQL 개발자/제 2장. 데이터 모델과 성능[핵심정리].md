# 제 2장. 데이터 모델과 성능[핵심정리]

[SQL 자격검정 실전문제] 교재 핵심정리

- **성능 데이터 모델링이란?**
    
    : 데이터베이스 성능 향상 목적
    
    : 설계 단계의 데이터 모델링 ~ 성능 관련 사항이 데이터 모델링에 반영 도움
    
    ※ 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK 등
    

- **1차 정규화 대상**
    
    : 중복 속성에 대한 분리
    
    : 로우 단위 중복
    
    : 칼럼 단위 중복
    
- **반정규화**
    
    : 정규화 된 엔터티, 속성, 관계에 대해  중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
    
    (반정규화 목적)
    
    : 시스템의 성능 향상, 개발과 운영의 단순화 목적
    
    : 데이터를 중복하여 성능을 향상시키기 위한 기법
    
    (반정규화 적용 이유)
    
    : 데이터를 조회할 때 디스크 I/O 량이 많아서 성능 저하 예상  ┐
    
    : 경로가 너무 멀어 조인으로 인한 성능 저하 예상                    │ → 반정규화 수행
    
    : 칼럼을 계산하여 읽을 때 성능 저하 예상                                ┘
    
    (반정규화 주의사항)
    
    : 데이터 무결성이 깨질 수 있는 위험 존재
    
    ** 무결성 : 데이터베이스 자료의 오류 없는 정확성과 안정성을 나타냄
    
- **반정규화 절차**
    
    1) 반정규화 대상조사
    
    - 범위 처리 빈도수 조사
    - 대량 범위 처리 조사
    - 통계성 프로세스 조사
    - 테이블 조인 개수
    
    2) 다른 방법 유도 검토
    
    - 뷰(VIEW) 테이블
    - 클러스터링 적용
    - 인덱스 조정
    - 응용 애플리케이션

3) 반정규화 적용

- 테이블 반정규화
- 속성의 반정규화
- 관계의 반정규화

- **반정규화 대상에 대해 다른 방법으로 처리**
    
    1) 지나치게 많은 조인(JOIN)이 걸려 데이터 조회하는 작업이 기술적으로 어려울 경우
    
    → 뷰(VIEW) 사용
    
    2) 대량 데이터 처리나 부분 처리에 의해 성능이 저하되는 경우
    
    → 클러스터링 적용하거나 인덱스를 조정함으로써 성능 향상 가능
    
    3) 대량의 데이터
    
    → Primary Key 성격에 따라 부분적인 테이블로 분리 가능
    
    → 파티셔닝 기법(Partitioning) 적용하여 성능 저하 방지 가능
    
    4) 응용 애플리케이션
    
    → 로직 구사하는 방법을 변경함으로써 성능 향상 가능
    
- **슈퍼/ 서브 타입 데이터 모델 변환 기술**
    - 개별 발생 트랜잭션 → 개별 테이블 구성
    - 슈퍼타입 + 서브타입 발생 트랜잭션 → 슈퍼타입 + 서브타입 테이블 구성
    - 전체를 하나로 묶어 발생된 트랜잭션 → 하나의 테이블 구성

- **PK 순서 결정 기준**
    
    👉 인덱스 정렬 구조를 이해한 상태에서 효율적인 인덱스 이용 가능토록 PK 순서 지정
    
    ‼ 인덱스 특징 
    
    👉  여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다.
    
    👉 앞쪽에 위치한 속성 값이 가급적 ‘=’, 아니면 최소한 범위 ‘BETWEEN’, ‘<>’가 들어와야 
    
    인덱스 이용 가능
    
- **분산 데이터베이스 장단점**
    
    **[장점]**
    
    - 지역 자치성, 점증적 시스템 용량 확장
    - 신뢰성과 가용성
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 데이터 가용성과 신뢰성 증가
    - 시스템 규모의 적절한 조정
    - 각 지역 사용자의 요구 수용 증대
    
    **[단점]**
    
    - 소프트웨어 개발 비용
    - 오류 잠재성 증대
    - 처리 비용 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위협