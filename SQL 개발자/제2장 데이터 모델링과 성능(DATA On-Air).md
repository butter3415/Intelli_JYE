# 제 2장. 데이터 모델과 성능

[DATA ON-AIR] 사이트 참조

## 성능 데이터 모델링의 개요

### 1. 성능 데이터 모델링 정의

: 데이터베이스 성능 향상을 목적으로 설계 단계의 데이터 모델링 때부터 성능과 관련된 사항이 모델링에 반영될 수 있도록 하는 것

👉 정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK 등

### 2. 성능 데이터 모델링 수행 시점

‼ 분석/ 설계 단계에서 데이터 모델 성능을 고려한 데이터 모델링 수행할 경우 성능 저하에 따른 재업무 비용을 최소화 할 수 있는 기회를 가지게 된다.

⇒ 처음부터 성능 따져서 만들어야 비용이 최소화 된다.

⇒ 분석/ 설계 단계에서 데이터 모델 대충하고, 성능 저하되는 문장 튜닝하면 나중에 돈 더 든다.

⇒ 특히, 데이터 증가가 빠르면 빠를수록 성능 저하에 따른 성능 개선 비용이 증가한다.

### 3. 성능 데이터 모델링 고려사항

**1) 데이터 모델링을 할 때 정규화를 정확하게 수행한다.**

⇒ 정규화된 모델이 데이터를 관심사별로 분산시키는 효과가 있어 그 자체로 성능 향상 가능

`정규화 : 개체에 존재하는 함수적 종속 관계를 이용하는 DB 구조를 안정화시키는 작업`

**2) 데이터베이스 용량 산정을 수행한다.**

⇒ 어떤 엔터티(테이블)에 데이터 집중되는지 파악 가능

**3) 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.**

⇒ SQL 문장의 조인관계 테이블에서 데이터 조회 칼럼 파악 가능

**4) 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.**

⇒ 테이블, 속성, 관계에 대해 포괄적인 반정규화 방법 적용 필요

**5) 이력 모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.**

⇒ PK/FK를 성능 우수한 순서대로 칼럼 순서 조정 필요(영향도 ↑)

**6) 성능 관점에서 데이터 모델을 검증한다.**

⇒ 일반적인 데이터 모델 규칙 뿐만 아니라 충분한 성능 고려 체크리스트 포함 검증 필요

## 정규화와 성능

### 4. 정규화를 통한 성능 향상 전략

‼ 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수 있고, 느려질 수도 있는 특성 존재

![Untitled](%E1%84%8C%E1%85%A6%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20d81f65951612478291352bfe5d86c6cb/Untitled.png)

❕정규화 👍 → 입력/ 수정/ 삭제 성능 향상    

❕ 반정규화 👍 → 조회 성능 향상

‼ 반정규화 만이 조회 성능을 향상시킨다⁉ ( ❌ ) 

→ 정규화를 통해 성능이 저하되기도 하고, 

→ 정규화를 통해 성능이 향상되는 경우도 있음

### 5. 함수적 종속성(Functional Dependency)에 근거한 정규화 수행 필요

▪함수의 종속성 : 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭

❕ 기준값 = 결정자 / 종속되는 값 = 종속자

▪정규화

: 데이터가 꼬이는 것을 막기 위해 테이블을 잘게 나누는 것

: (목적) 반복적 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치하는 것

: 프로젝트 수행에서 정규화는 선택 사항이 아닌 필수 사항

— 1차 정규화 : 같은 성격, 내용 칼럼이 연속될 때 칼럼 제거, 테이블 생성

— 2차 정규화 : PK 복합키 구성일 때 부분적 함수 종속 관계 테이블 분리

— 3차 정규화 : PK가 아닌 일반 칼럼에 의존하는 칼럼 분리

## 반정규화와 성능

### 6. 반정규화를 통한 성능 향상 전략

### 가. 반정규화의 정의

: 정규화된 엔터티, 속성, 관계에 대해 시스템 성능 향상과 개발, 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법

: 성능 향상을 위해 정규화를 포기하는 것, 

but 데이터 무결성이 보장 되지 않으므로 제한적으로 사용해야 함.

‼ (적용 이유) 데이터 조회 시 디스크 I/O가 많거나 경로가 너무 멀어  조인으로 인한 성능 저하 발생 시, 칼럼 계산하여 읽을 때 성능 저하되는 경우 반정규화 수행

‼ 반정규화를 적용할 때 데이터를 입력, 수정, 삭제할 때는 성능이 떨어지는 점을 기억해야 하며, 데이터 무결성 유지에 주의해야 한다.

![Untitled](%E1%84%8C%E1%85%A6%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20d81f65951612478291352bfe5d86c6cb/Untitled%201.png)

‼ 기본적으로 정규화는 입력/ 수정/ 삭제, 조회에 대하여 성능 향상

‼                     반정규화는 여러 개의 조인이 걸려야만 하는 경우 사용

### 나. 반정규화 적용 방법

**1) 반정규화 대상 조사**

‼ (범위 처리 빈도수 조사) 자주 사용되는 테이블에 접근하는 프로세스가 많고 항상 일정한 범위만 조회하는 경우에 반정규화 검토 

‼ (대량 범위 처리 조사) 대량의 데이터 존재, 대량 데이터 범위 처리하는 경우 처리 범위를 일정하게 줄이지 않으면 성능 보장 못할 경우

‼ (통계성 프로세스 조사) 통계 정보 필요 시 별도 통계테이블(반정규화 테이블) 생성

‼ (테이블 조인 개수) 많은 조인이 걸려 데이터 조회 작업이 기술적으로 어려울 경우 반정규화 검토

**2) 다른 방법 유도 검토**

‼ (뷰(VIEW) 테이블) 많은 조인이 걸려 데이터 조회 작업이 기술적으로 어려울 경우 뷰(view) 사용하여 해결

‼ (클러스터링 적용) 대량 데이터를 특정 클러스터링 팩트에 의해 저장 방식을 다르게 하는 방법 _ 조회 중심인 경우

‼ (인덱스 조정_파티셔닝 기법) 물리적인 저장 기법

‼ (응용애플리케이션) 로직 구사 방법 변경_캐쉬 등

**3) 반정규화 적용**

‼ 테이블 반정규화

‼ 속성 반정규화

‼ 관계 반정규화

### 7. 반정규화의 기법

### **가. 테이블 반정규화**

**▪ 테이블 병합**

1) 1:1 관계 테이블 병합 : 1:1 관계를 통합하여 성능 향상

2) 1:M 관계 테이블 병합 : 1:M 관계를 통합하여 성능 향상

3) 슈퍼/ 서브 관계를 통합하여 성능 향사

**▪ 테이블 분할**

1) 수직 분할 

: 칼럼 단위 테이블 디스크 I/O를 분산 처리 하기 위해 테이블을 1:1로 분리하여 성능 향상

2) 수평 분할

: 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근 효율성을 높여 성능 향상하기 위해 로우 단위로 테이블 쪼갬

**▪ 테이블 추가**

1) 중복 테이블 추가

: 동일한 테이블 구조 중복하여 원격 조인을 제거 후 성능 향상

2) 통계 테이블 추가

: SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능 향상

3) 이력 테이블 추가

: 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재 시켜 성능 향상

4) 부분 테이블 추가

: 자주 이용하는 집중화 된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아 놓은 별도의 반정규화 테이블 생성

### **나. 칼럼 반정규화**

**▪ 중복 칼럼 추가**

: 조인을 감소시키기 위해 중복된 칼럼 위치 시킴

**▪ 파생 칼럼 추가**

: 트랜잭션 처리 시점 계산에 의해 발생되는 성능 저하 예방 위해 미리 값을 계산하여 칼럼에 보관

**▪ 이력테이블 칼럼 추가**

: 이력 데이터 처리 시 불특정 날 조회나 최근 값을 조회할 때 발생되는 성능 저하 예방 위해 이력 테이블에 기능성 칼럼 추가

**▪ PK에 의한 칼럼 추가**

: 단일 PK 안에서 특정 값을 별도로 조회하는 경우 성능 저하 발생 가능성 있어 일반 속성으로 포함하는 방법

**▪ 응용시스템 오작동 위한 칼럼 추가**

: 업무적 의미 없으나 데이터 처리 시 잘못 처리하여 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법

### **다. 관계 반정규화**

**▪ 중복 관계 추가** 

: 여러 경로를 거쳐 조인 가능하나 이 때 발생하는 성능 저하 예방 위해 추가적인 관계 맺는 방법 

## 대량 데이터에 따른 성능

### 8. 대량 데이터에 따른 테이블 분할

‼ 설계가 잘 되어 있는 데이터 모델도 대량의 데이터가 집약되어 있고, 하나의 하드웨어 공간에 저장되어 있으면 성능 저하 피하기가 어려움

(Ex. 하나의 고속도로 차선을 넓게 시공하여 건설해도 교통량이 많으면 넓은 도로라고 하여도 정체 현상을 보인다.)

‼ 프로젝트 수행 시 하나의 테이블에 300개 이상 칼럼 소유한 경우 多

→ 많은 칼럼은 로우체이닝 & 로우마이그레이션 多 → 성능 저하

▪ 로우체이닝 : 로우 길이가 길어 데이터 블록 하나에 데이터가 저장되지 않고, 두 개 이상 블록에 걸쳐 하나의 로우가 저장되어 있는 형태

▪ 로우마이그레이션 : 데이터 블록에서 수정 발생하면 수정 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록 빈 공간 찾아 저장함

⇒ 로우체이닝 & 로우마이그레션 발생 ⇒ 많은 블록 데이터 저장 ⇒ 메모리에서 디스크와 I/O(입력/출력) 발생 시 불필요 I/O 발생 ⇒ 성능 저하

### 9. 대량 데이터 저장 및 처리로 인한 성능

: 많은 양의 데이터가 예상될 경우 파티셔닝 적용 or PK에 의해 테이블 분할하는 방법 적용

- **가. RANGE PARTITION 적용**
    
    : 대상 테이블이 날짜 or 숫자 값으로 분리 가능하고 각 영역별 트랜잭션 분리될 경우 적용
    
    : 데이터 보관 주기에 따라 테이블 데이터를 쉽게 지우는 것이 가능⇒ 데이터 보관 주기에 따른 테이블 관리 용이
    
    (시간별로 정렬 되어 해당 시간별 데이터 삭제 용이)
    
- **나. LIST PARTITION 적용**
    
    : 핵심적 코드값 등으로 PK 구성
    
    : 대용량 데이터를 특정 값에 따라 분리 저장 가능
    
    : RANGE PARTITION과 같이 데이터 보관 주기에 따른 삭제 기능 ❌
    
- **다. HASH PARTITION 적용**
    
    : 지정된 HASH 조건에 따라 해쉬 알고리즘 적용되어 테이블 분리
    

### 10. 테이블에 대한 수평분할/ 수직분할 절차

**1) 데이터 모델링 완성**

**2) 데이터베이스 용량 산정**

**3) 대량 데이터 처리되는 테이블에 대해 트랜잭션 처리 패턴 분석**

**4) 집중화 된 단위(칼럼, 로우 단위)로 테이블 분리하는 것 검토**

➕ 칼럼의 수가 많은 경우 - 1:1 형태로 테이블 분리

➕ 데이터 용량이 많은 경우 - 파티셔닝 전략 고려

## 데이터 베이스 구조와 성능

### 11. 슈퍼타입/ 서브타입 모델 성능 고려 방법

- **가. 슈퍼/ 서브타입 데이터 모델 개요**
    
    : 슈퍼 타입 👉 공통 부분 
    
    : 서브 타입 👉  공통에서 상속 받아 다른 엔터티와 차이가 있는 속성
    
    ⏭ 업무 구성 데이터의 특징을 공통과 차이점 특징 고려하여 효과적 표현 가능
    
- **나. 슈퍼/ 서브타입 데이터 모델 변환**
    
    : 변환을 잘못하면 성능 저하
    
    1) 트랜잭션은 항상 일괄로 처리, 테이블은 개별로 유지
    
    → Union 연산에 의해 성능 저하 가능성 ⭕
    
    2) 트랜잭션은 항상 서브타입 개별 처리, 테이블 하나로 통합
    
    → 불필요한 많은 양의 데이터 집약되어 있어 성능 저하 ⭕
    
    3) 트랜잭션은 항상 슈퍼 + 서브 타입 공통 처리
    
    → 개별 유지되어 있거나 하나 테이블로 집약되어 성능 저하 ⭕ 
    
- **다. 슈퍼/ 서브타입 데이터 모델 변환 기술**
    
    1) 개별 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
    
    : 모두 분리하여 1:1 관계 갖도록 함 
    
    → 슈퍼/서브 타입에 꼭 필요한 속성만을 가지게 하기 위함
    
    2) 슈퍼+서브 타입 트랜잭션 → 슈퍼+서브 타입 테이블 구성
    
    3) 전체를 하나로 묶은 트랜잭션 발생 → 하나의 테이블로 구성
    
    ![Untitled](%E1%84%8C%E1%85%A6%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20d81f65951612478291352bfe5d86c6cb/Untitled%202.png)
    

### 12. 인덱스 특성 고려한 PK/FK 데이터베이스 성능 향상

▪ 인덱스 : 데이터 조회 시 가장 효과적으로 처리 가능한 접근 경로를 제공하는 오브젝트

‼ 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낸다.

‼ 앞쪽 위치한 속성 값이 가급적 ‘=’ 아니면 최소한 범위 ‘BETWEEN’ ‘<>’가 들어와야 인덱스를 이용할 수 있다.

## 분산 데이터베이스와 성능

### 13. 분산 데이터베이스

: 여러 곳으로 분산 되어 있는 데이터 베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스

: 논리적으로 동일한 시스템에 속하지만, 컴퓨터 네트워크를 통해 물리적으로 분산 되어 있는 데이터 집합

: 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터 베이스를 여러 지역 여러 노드로 위치 시켜 사용성/ 성능을 극대화 시킨 DB

### 14. 분산 데이터베이스 투명성(Transparency)

: 분산 데이터베이스가 되기 위해서 6가지 투명성(Transparency)을 만족해야 한다.

- **분할 투명성(단편화)**
    
    : 하나의 논리적 Relation이 여러 단편으로 분할 되어 각 단편의 사본이 여러 site에 저장
    
- **위치 투명성**
    
    : 사용하려는 데이터 저장 장소 명시 불필요. 
    
    : 위치정보가 System Catalog에 유지되어야 함
    
- **지역사상 투명성**
    
    : 지역 DBMS와 물리적 DB 사이의 Mapping 보장. 
    
    : 각 지역 시스템 이름과 무관한 이름 사용 가능
    
- **중복 투명성**
    
    : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
    
- **장애 투명성**
    
    : 구성 요소(DBMS, Computer)의 장애에 무관한 Transaction 원자성 유지
    
- **병행 투명성**
    
    : 다수 Transaction 동시 수행 시 결과의 일관성 유지
    
    : Time Stamp, 분산 2단계 Locking 이용 구현
    

### 15. 분산 데이터베이스 장단점

**<장점👍>**

— 지역 자치성, 점증적 시스템 용량 확장

— 신뢰성과 가용성

— 효용성과 융통성

— 빠른 응답 속도와 통신 비용 절감

— 데이터 가용성과 신뢰성 증가

— 시스템 규모의 적절한 조절

— 각 지역 사용자의 요구 수용 증대

**<단점👎>**

— 소프트웨어 개발 비용 증가

— 오류의 잠재성 증대

— 처리 비용의 증대

— 설계, 관리의 복잡성과 비용

— 불규칙한 응답 속도

— 통제의 어려움

— 데이터 무결성에 대한 위협

### 16. 분산 데이터베이스 적용 기법

- **가. 테이블 위치 분산**
    
    : 설계된 테이블 위치를 각각 다르게 위치 시키는 것
    
    : DB를 본사와 지사 단위로 분산 시키기 가능
    
- **나. 테이블 분할(Fragmentation) 분산**
    
    : 각각의 테이블 쪼개어 분산하는 방법
    
    **1) 수평 분할(Horizontal Fragmentation)**
    
    : 지사에 따라 테이블 칼럼 값 기준으로 로우 분리(칼럼 분리 ❌)
    
    : 각 지사별 사용 로우(Row)가 다를 때 이용
    
    : 지사별로 별도로 존재하므로 중복 발생 ❌
    
    → 한 지사에서 하나의 데이터만 존재 👉 데이터 무결성 보장
    
    ![Untitled](%E1%84%8C%E1%85%A6%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20d81f65951612478291352bfe5d86c6cb/Untitled%203.png)
    
    **2) 수직 분할(Vertical Fragmentation)**
    
    : 지사에 따라 테이블 칼럼 값 기준으로 칼럼 분리(로우 분리 ❌)
    
    : 각각 테이블에는 동일한 Primary Key 구조, 값 있어야 함
    
    : 데이터 집합시켜 놓아도 PK는 하나로 표현 👉 데이터 중복 발생 ❌
    
    ![Untitled](%E1%84%8C%E1%85%A6%202%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%82%E1%85%B3%E1%86%BC%20d81f65951612478291352bfe5d86c6cb/Untitled%204.png)
    
- **다. 테이블 복제(Replication) 분산**
    
    : 동일한 테이블 👉 다른 지역, 서버에서 동시에 생성하여 관리함
    
    **1) 부분복제(Segment Replication)**
    
    : 마스터 DB에서 테이블 일부 내용만 다른 지역이나 서버에 위치
    
    : 본사 DB 테이블 👉 전체 내용이 들어간다. 
    
    : 각 지사 DB 테이블 👉 지사별 관계 데이터만 들어간다.
    
    **2) 광역복제(Broadcast Replication)**
    
    : 마스터 DB 테이블 내용이 각 지역이나 서버에 존재
    
    : 본사, 지사 DB 테이블 👉 동일한 정보, 데이터량을 가진다.
    
- **라. 테이블 요약(Summarization) 분산**
    
    : 지역, 서버 간 데이터 비슷 but 서로 다른 유형으로 존재한 경우
    
    **1) 분석요약(Rollup Replication)**
    
    : 각 지사별 요약 정보를 본사 통합 후 전체 요약 정보로 재산출
    
    : 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터 이용하여 통합된 데이터 산출하는 방식
    
    (Ex. 판매실적, 지사 A, 지사B)
    
    **2) 통합요약(Consolidatiion Replication)**
    
    : 각 지사별 다른 내용 정보를 본사 통합 후 전체 요약 정보로 재산출
    
    : 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출하는 방식
    
    (Ex. 지사A : C제품, 지사 B : D제품)
    

### 17. 분산 DB 설계 고려해야 하는 경우

1) 성능이 중요한 사이트에 적용

2) 공통코드, 기준정보, 마스터 데이터 등 분산 환경 구성하면 성능 향상

3) 실시간 동기화가 요구되지 않을 때   

   실시간(Near Real Time) 업무적 특징 갖고 있어도 분산 환경 구성 가능

4) 특정 서버에 부하가 집중되어 부하를 분산할 경우

5) 백업 사이트 구성할 때 간단 분산 기능 적용하여 구성 가능