//
// Created by 82104 on 2023-02-11.
// 04 오버플로우와 언더플로우

// 컴퓨터의 시스템에서 숫자를 사용할 경우 자료형에 따라 사용 가능한 메모리가 한정되어 있다.
// 자료형의 최대값보다 크거나 최소값보다 작은 값을 저장하려고 하면 문제가 발생하는데 이 문제를 '오버플로우와 언더플로우' 라고 한다.

# include <iostream>
# include <limits>
using namespace std;

int main() {

// [2] 정수의 오버플로우와 언더플로우
// - 부호 없는 정수의 오버플로우와 언더플로우
//   오버플로우, 언더플로우 발생하면 한바퀴를 돌아 범위를 지키려고 한다.
//   <오버플로우(범위보다 큰 값 입력) : 시계 방향 >
//   <언더플로우(범위보다 작은 값 입력) : 시계 반대 방향>

//  * 부호 없는 정수 자료형의 오버플로우와 언더플로우 확인하기
//    unsigned int num1 = numeric_limits<unsigned int>::max();
//    unsigned int num2 = numeric_limits<unsigned int>::min();
//    cout << "부호 X 정수 최대값 : " << num1 << endl;   // 4294967295
//    cout << "부호 X 정수 최소값 : " << num2 << endl;   // 0
//
//    num1 += 1;  // 4294967295 + 1
//    num2 -= 1;  // 0 - 1
//
//    cout << "오버플로우가 일어난 num1 +1 값 : " << num1 << endl;  // 0 (시계 방향)
//    cout << "언더플로우가 일어난 num2 -1 값 : " << num2 << endl;  // 4294967295 (시계 반대 방향)

// 부호 있는 정수의 오버플로우와 언더플로우
// 양수 최대값보다 큰 값 -> 음수 최대값
// 음수 최소값보다 작은 값 -> 양수 최대값

// * 부호 있는 정수 자료형의 오버플로우와 언더플로우 확인하기

    int num1 = numeric_limits<int>::max();
    int num2 = numeric_limits<int>::min();

    cout << "부호 O 정수 최대값 : " << num1 << endl;
    cout << "부호 O 정수 최소값 : " << num2 << endl;

    num1 += 1;  // 2147483647
    num2 -= 1;  // -2147483648

    cout << "오버플로우 발생 num1 : " << num1 << endl; // -2147483648
    cout << "언더플로우 발생 num2 : " << num2 << endl; // 2147483647

}